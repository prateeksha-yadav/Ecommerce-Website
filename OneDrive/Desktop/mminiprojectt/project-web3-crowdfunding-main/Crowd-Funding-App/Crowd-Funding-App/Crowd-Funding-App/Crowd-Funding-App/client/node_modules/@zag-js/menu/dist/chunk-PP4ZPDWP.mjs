import {
  getEventPoint,
  hasProp,
  isArray,
  isObject,
  isTouchEvent,
  supportsMouseEvent,
  supportsPointerEvent,
  supportsTouchEvent
} from "./chunk-XVH4VTFY.mjs";
import {
  add,
  contains,
  dom,
  findByTypeahead,
  isElementEditable,
  remove
} from "./chunk-QSWY67NH.mjs";

// src/menu.machine.ts
import { createMachine, guards, ref } from "@zag-js/core";
import { trackDismissableElement } from "@zag-js/dismissable";

// ../../utilities/core/src/functions.ts
var runIfFn = (v, ...a) => {
  const res = typeof v === "function" ? v(...a) : v;
  return res != null ? res : void 0;
};

// ../../utilities/core/src/object.ts
function compact(obj) {
  if (obj === void 0)
    return obj;
  return Object.fromEntries(
    Object.entries(obj).filter(([, value]) => value !== void 0).map(([key, value]) => [key, isObject(value) ? compact(value) : value])
  );
}

// ../../utilities/dom/src/listener.ts
var isRef = (v) => hasProp(v, "current");
var fallback = { pageX: 0, pageY: 0, clientX: 0, clientY: 0 };
function extractInfo(event, type = "page") {
  const point2 = isTouchEvent(event) ? event.touches[0] || event.changedTouches[0] || fallback : event;
  return {
    point: {
      x: point2[`${type}X`],
      y: point2[`${type}Y`]
    }
  };
}
function addDomEvent(target, eventName, handler, options) {
  const node = isRef(target) ? target.current : runIfFn(target);
  node == null ? void 0 : node.addEventListener(eventName, handler, options);
  return () => {
    node == null ? void 0 : node.removeEventListener(eventName, handler, options);
  };
}
function addPointerEvent(target, event, listener, options) {
  var _a;
  const type = (_a = getEventName(event)) != null ? _a : event;
  return addDomEvent(target, type, wrapHandler(listener, event === "pointerdown"), options);
}
function wrapHandler(fn, filter = false) {
  const listener = (event) => {
    fn(event, extractInfo(event));
  };
  return filter ? filterPrimaryPointer(listener) : listener;
}
function filterPrimaryPointer(fn) {
  return (event) => {
    var _a;
    const win = (_a = event.view) != null ? _a : window;
    const isMouseEvent = event instanceof win.MouseEvent;
    const isPrimary = !isMouseEvent || isMouseEvent && event.button === 0;
    if (isPrimary)
      fn(event);
  };
}
var mouseEventNames = {
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointercancel: "mousecancel",
  pointerover: "mouseover",
  pointerout: "mouseout",
  pointerenter: "mouseenter",
  pointerleave: "mouseleave"
};
var touchEventNames = {
  pointerdown: "touchstart",
  pointermove: "touchmove",
  pointerup: "touchend",
  pointercancel: "touchcancel"
};
function getEventName(evt) {
  if (supportsPointerEvent())
    return evt;
  if (supportsTouchEvent())
    return touchEventNames[evt];
  if (supportsMouseEvent())
    return mouseEventNames[evt];
  return evt;
}

// ../../utilities/dom/src/next-tick.ts
function raf(fn) {
  const id = globalThis.requestAnimationFrame(fn);
  return function cleanup() {
    globalThis.cancelAnimationFrame(id);
  };
}

// src/menu.machine.ts
import { getBasePlacement, getPlacement } from "@zag-js/popper";

// ../../utilities/rect/src/rect.ts
var point = (x, y) => ({ x, y });
function createRect(r) {
  const { x, y, width, height } = r;
  const midX = x + width / 2;
  const midY = y + height / 2;
  return {
    x,
    y,
    width,
    height,
    minX: x,
    minY: y,
    maxX: x + width,
    maxY: y + height,
    midX,
    midY,
    center: point(midX, midY)
  };
}
function getRectCorners(v) {
  const top = point(v.minX, v.minY);
  const right = point(v.maxX, v.minY);
  const bottom = point(v.maxX, v.maxY);
  const left = point(v.minX, v.maxY);
  return { top, right, bottom, left };
}

// ../../utilities/rect/src/get-polygon.ts
function getElementPolygon(rectValue, placement) {
  const rect = createRect(rectValue);
  const { top, right, left, bottom } = getRectCorners(rect);
  const [base] = placement.split("-");
  return {
    top: [left, top, right, bottom],
    right: [top, right, bottom, left],
    bottom: [top, left, bottom, right],
    left: [right, top, left, bottom]
  }[base];
}

// ../../utilities/rect/src/polygon.ts
function isPointInPolygon(polygon, point2) {
  const { x, y } = point2;
  let c = false;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const xi = polygon[i].x;
    const yi = polygon[i].y;
    const xj = polygon[j].x;
    const yj = polygon[j].y;
    if (yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi) {
      c = !c;
    }
  }
  return c;
}

// src/menu.machine.ts
var { not, and } = guards;
function machine(userContext) {
  const ctx = compact(userContext);
  return createMachine(
    {
      id: "menu",
      initial: "unknown",
      context: {
        highlightedId: null,
        hoverId: null,
        parent: null,
        children: {},
        intentPolygon: null,
        loop: false,
        suspendPointer: false,
        anchorPoint: null,
        closeOnSelect: true,
        isPlacementComplete: false,
        focusTriggerOnClose: true,
        ...ctx,
        pointerdownNode: null,
        typeahead: findByTypeahead.defaultOptions,
        positioning: {
          placement: "bottom-start",
          gutter: 8,
          ...ctx.positioning
        }
      },
      computed: {
        isSubmenu: (ctx2) => ctx2.parent !== null,
        isRtl: (ctx2) => ctx2.dir === "rtl",
        isTypingAhead: (ctx2) => ctx2.typeahead.keysSoFar !== ""
      },
      watch: {
        isSubmenu: "setSubmenuPlacement",
        anchorPoint: "applyAnchorPoint"
      },
      on: {
        SET_PARENT: {
          actions: "setParentMenu"
        },
        SET_CHILD: {
          actions: "setChildMenu"
        },
        OPEN: {
          target: "open",
          actions: "invokeOnOpen"
        },
        OPEN_AUTOFOCUS: {
          internal: true,
          target: "open",
          actions: ["focusFirstItem", "invokeOnOpen"]
        },
        CLOSE: {
          target: "closed",
          actions: "invokeOnClose"
        },
        RESTORE_FOCUS: {
          actions: "restoreFocus"
        },
        SET_VALUE: {
          actions: ["setOptionValue", "invokeOnValueChange"]
        },
        SET_HIGHLIGHTED_ID: {
          actions: "setFocusedItem"
        }
      },
      states: {
        unknown: {
          on: {
            SETUP: "idle"
          }
        },
        idle: {
          on: {
            CONTEXT_MENU_START: {
              target: "opening:contextmenu",
              actions: "setAnchorPoint"
            },
            CONTEXT_MENU: {
              target: "open",
              actions: ["setAnchorPoint", "invokeOnOpen"]
            },
            TRIGGER_CLICK: {
              target: "open",
              actions: "invokeOnOpen"
            },
            TRIGGER_FOCUS: {
              guard: not("isSubmenu"),
              target: "closed"
            },
            TRIGGER_POINTERMOVE: {
              guard: "isSubmenu",
              target: "opening"
            }
          }
        },
        "opening:contextmenu": {
          after: {
            LONG_PRESS_DELAY: {
              target: "open",
              actions: "invokeOnOpen"
            }
          },
          on: {
            CONTEXT_MENU_CANCEL: {
              target: "closed",
              actions: "invokeOnClose"
            }
          }
        },
        opening: {
          after: {
            SUBMENU_OPEN_DELAY: {
              target: "open",
              actions: "invokeOnOpen"
            }
          },
          on: {
            BLUR: {
              target: "closed",
              actions: "invokeOnClose"
            },
            TRIGGER_POINTERLEAVE: {
              target: "closed",
              actions: "invokeOnClose"
            }
          }
        },
        closing: {
          tags: ["visible"],
          activities: ["trackPointerMove", "trackInteractOutside"],
          after: {
            SUBMENU_CLOSE_DELAY: {
              target: "closed",
              actions: ["focusParentMenu", "restoreParentFocus", "invokeOnClose"]
            }
          },
          on: {
            MENU_POINTERENTER: {
              target: "open",
              actions: "clearIntentPolygon"
            },
            POINTER_MOVED_AWAY_FROM_SUBMENU: {
              target: "closed",
              actions: ["focusParentMenu", "restoreParentFocus"]
            }
          }
        },
        closed: {
          entry: ["clearFocusedItem", "focusTrigger", "clearAnchorPoint", "resumePointer"],
          on: {
            CONTEXT_MENU_START: {
              target: "opening:contextmenu",
              actions: "setAnchorPoint"
            },
            CONTEXT_MENU: {
              target: "open",
              actions: ["setAnchorPoint", "invokeOnOpen"]
            },
            TRIGGER_CLICK: {
              target: "open",
              actions: "invokeOnOpen"
            },
            TRIGGER_POINTERMOVE: {
              guard: "isTriggerItem",
              target: "opening"
            },
            TRIGGER_BLUR: "idle",
            ARROW_DOWN: {
              target: "open",
              actions: ["focusFirstItem", "invokeOnOpen"]
            },
            ARROW_UP: {
              target: "open",
              actions: ["focusLastItem", "invokeOnOpen"]
            }
          }
        },
        open: {
          tags: ["visible"],
          activities: ["trackInteractOutside", "computePlacement"],
          entry: ["focusMenu", "resumePointer"],
          exit: ["clearPointerdownNode"],
          on: {
            TRIGGER_CLICK: {
              guard: not("isTriggerItem"),
              target: "closed",
              actions: "invokeOnClose"
            },
            TAB: [
              {
                guard: "isForwardTabNavigation",
                actions: ["focusNextItem"]
              },
              { actions: ["focusPrevItem"] }
            ],
            ARROW_UP: {
              actions: ["focusPrevItem", "focusMenu"]
            },
            ARROW_DOWN: {
              actions: ["focusNextItem", "focusMenu"]
            },
            ARROW_LEFT: {
              guard: "isSubmenu",
              target: "closed",
              actions: ["focusParentMenu", "invokeOnClose"]
            },
            HOME: {
              actions: ["focusFirstItem", "focusMenu"]
            },
            END: {
              actions: ["focusLastItem", "focusMenu"]
            },
            REQUEST_CLOSE: {
              target: "closed",
              actions: "invokeOnClose"
            },
            ARROW_RIGHT: {
              guard: "isTriggerItemFocused",
              actions: "openSubmenu"
            },
            ENTER: [
              {
                guard: "isTriggerItemFocused",
                actions: "openSubmenu"
              },
              {
                guard: "closeOnSelect",
                target: "closed",
                actions: "clickFocusedItem"
              },
              {
                actions: "clickFocusedItem"
              }
            ],
            ITEM_POINTERMOVE: [
              {
                guard: and(not("suspendPointer"), not("isTargetFocused")),
                actions: ["focusItem", "focusMenu"]
              },
              {
                guard: not("isTargetFocused"),
                actions: "setHoveredItem"
              }
            ],
            ITEM_POINTERLEAVE: {
              guard: and(not("suspendPointer"), not("isTriggerItem")),
              actions: "clearFocusedItem"
            },
            ITEM_CLICK: [
              {
                guard: and(not("isTriggerItemFocused"), not("isFocusedItemEditable"), "closeOnSelect"),
                target: "closed",
                actions: [
                  "invokeOnSelect",
                  "changeOptionValue",
                  "invokeOnValueChange",
                  "closeRootMenu",
                  "invokeOnClose"
                ]
              },
              {
                guard: and(not("isTriggerItemFocused"), not("isFocusedItemEditable")),
                actions: ["invokeOnSelect", "changeOptionValue", "invokeOnValueChange"]
              },
              { actions: ["focusItem"] }
            ],
            TRIGGER_POINTERLEAVE: {
              target: "closing",
              actions: "setIntentPolygon"
            },
            ITEM_POINTERDOWN: {
              actions: ["setPointerdownNode", "focusItem"]
            },
            TYPEAHEAD: {
              actions: "focusMatchedItem"
            },
            FOCUS_MENU: {
              actions: "focusMenu"
            }
          }
        }
      }
    },
    {
      delays: {
        LONG_PRESS_DELAY: 700,
        SUBMENU_OPEN_DELAY: 100,
        SUBMENU_CLOSE_DELAY: 100
      },
      guards: {
        closeOnSelect: (ctx2, evt) => {
          var _a, _b;
          return !!((_b = (_a = evt.option) == null ? void 0 : _a.closeOnSelect) != null ? _b : ctx2.closeOnSelect);
        },
        isMenuFocused: (ctx2) => {
          const menu = dom.getContentEl(ctx2);
          const activeElement = dom.getActiveElement(ctx2);
          return contains(menu, activeElement);
        },
        isTargetFocused: (ctx2, evt) => ctx2.highlightedId === evt.target.id,
        isTriggerItem: (_ctx, evt) => dom.isTriggerItem(evt.target),
        isTriggerItemFocused: (ctx2, evt) => {
          var _a;
          const target = (_a = evt.target) != null ? _a : dom.getFocusedItem(ctx2);
          return !!(target == null ? void 0 : target.hasAttribute("aria-controls"));
        },
        isForwardTabNavigation: (_ctx, evt) => !evt.shiftKey,
        isSubmenu: (ctx2) => ctx2.isSubmenu,
        suspendPointer: (ctx2) => ctx2.suspendPointer,
        isFocusedItemEditable: (ctx2) => isElementEditable(dom.getFocusedItem(ctx2)),
        isWithinPolygon: (ctx2, evt) => {
          if (!ctx2.intentPolygon)
            return false;
          return isPointInPolygon(ctx2.intentPolygon, evt.point);
        }
      },
      activities: {
        computePlacement(ctx2) {
          if (ctx2.anchorPoint)
            return;
          ctx2.currentPlacement = ctx2.positioning.placement;
          return getPlacement(dom.getTriggerEl(ctx2), dom.getPositionerEl(ctx2), {
            ...ctx2.positioning,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
              ctx2.isPlacementComplete = true;
            }
          });
        },
        trackInteractOutside(ctx2, _evt, { send }) {
          return trackDismissableElement(dom.getContentEl(ctx2), {
            exclude: [dom.getTriggerEl(ctx2)],
            onEscapeKeyDown(event) {
              if (ctx2.isSubmenu)
                event.preventDefault();
              closeRootMenu(ctx2);
            },
            onPointerDownOutside(event) {
              ctx2.focusTriggerOnClose = !event.detail.focusable;
            },
            onDismiss() {
              send({ type: "REQUEST_CLOSE", src: "interact-outside" });
            }
          });
        },
        trackPointerMove(ctx2, _evt, { guards: guards2, send }) {
          const { isWithinPolygon } = guards2;
          ctx2.parent.state.context.suspendPointer = true;
          const doc = dom.getDoc(ctx2);
          return addPointerEvent(doc, "pointermove", (e) => {
            const isMovingToSubmenu = isWithinPolygon(ctx2, { point: getEventPoint(e) });
            if (!isMovingToSubmenu) {
              send("POINTER_MOVED_AWAY_FROM_SUBMENU");
              ctx2.parent.state.context.suspendPointer = false;
            }
          });
        }
      },
      actions: {
        setAnchorPoint(ctx2, evt) {
          ctx2.anchorPoint = evt.point;
        },
        clearAnchorPoint(ctx2) {
          ctx2.anchorPoint = null;
        },
        applyAnchorPoint(ctx2) {
          const point2 = ctx2.anchorPoint;
          if (!point2)
            return;
          const el = dom.getPositionerEl(ctx2);
          if (!el)
            return;
          raf(() => {
            Object.assign(el.style, {
              position: "absolute",
              top: "0",
              left: "0",
              transform: `translate3d(${point2.x}px, ${point2.y}px, 0)`
            });
            ctx2.isPlacementComplete = true;
          });
        },
        setSubmenuPlacement(ctx2) {
          if (!ctx2.isSubmenu)
            return;
          ctx2.positioning.placement = ctx2.isRtl ? "left-start" : "right-start";
          ctx2.positioning.gutter = 0;
        },
        invokeOnValueChange(ctx2, evt) {
          var _a, _b, _c;
          if (!ctx2.value)
            return;
          const name = (_b = evt.name) != null ? _b : (_a = evt.option) == null ? void 0 : _a.name;
          if (!name)
            return;
          const values = ctx2.value[name];
          const valueAsArray = isArray(values) ? Array.from(values) : values;
          (_c = ctx2.onValueChange) == null ? void 0 : _c.call(ctx2, { name, value: valueAsArray });
        },
        setOptionValue(ctx2, evt) {
          if (!ctx2.value)
            return;
          ctx2.value[evt.name] = evt.value;
        },
        changeOptionValue(ctx2, evt) {
          if (!evt.option || !ctx2.value)
            return;
          const { value, type, name } = evt.option;
          const values = ctx2.value[name];
          if (type === "checkbox" && isArray(values)) {
            ctx2.value[name] = values.includes(value) ? remove(values, value) : add(values, value);
          } else {
            ctx2.value[name] = value;
          }
        },
        clickFocusedItem(ctx2) {
          var _a;
          (_a = dom.getFocusedItem(ctx2)) == null ? void 0 : _a.click();
        },
        setIntentPolygon(ctx2, evt) {
          const menu = dom.getContentEl(ctx2);
          const placement = ctx2.currentPlacement;
          if (!menu || !placement)
            return;
          const rect = menu.getBoundingClientRect();
          const polygon = getElementPolygon(rect, placement);
          if (!polygon)
            return;
          const rightSide = getBasePlacement(placement) === "right";
          const bleed = rightSide ? -5 : 5;
          ctx2.intentPolygon = [{ ...evt.point, x: evt.point.x + bleed }, ...polygon];
        },
        clearIntentPolygon(ctx2) {
          ctx2.intentPolygon = null;
        },
        resumePointer(ctx2) {
          if (!ctx2.parent)
            return;
          ctx2.parent.state.context.suspendPointer = false;
        },
        setFocusedItem(ctx2, evt) {
          ctx2.highlightedId = evt.id;
        },
        clearFocusedItem(ctx2) {
          ctx2.highlightedId = null;
        },
        focusMenu(ctx2) {
          raf(() => {
            const activeEl = dom.getActiveElement(ctx2);
            const contentEl = dom.getContentEl(ctx2);
            if (contains(contentEl, activeEl))
              return;
            contentEl == null ? void 0 : contentEl.focus();
          });
        },
        focusFirstItem(ctx2) {
          const first = dom.getFirstEl(ctx2);
          if (!first)
            return;
          ctx2.highlightedId = first.id;
        },
        focusLastItem(ctx2) {
          const last = dom.getLastEl(ctx2);
          if (!last)
            return;
          ctx2.highlightedId = last.id;
        },
        focusNextItem(ctx2, evt) {
          var _a;
          const next = dom.getNextEl(ctx2, evt.loop);
          ctx2.highlightedId = (_a = next == null ? void 0 : next.id) != null ? _a : null;
        },
        focusPrevItem(ctx2, evt) {
          var _a;
          const prev = dom.getPrevEl(ctx2, evt.loop);
          ctx2.highlightedId = (_a = prev == null ? void 0 : prev.id) != null ? _a : null;
        },
        invokeOnSelect(ctx2) {
          var _a;
          if (!ctx2.highlightedId)
            return;
          (_a = ctx2.onSelect) == null ? void 0 : _a.call(ctx2, { value: ctx2.highlightedId });
          if (!ctx2.closeOnSelect) {
            ctx2.pointerdownNode = null;
          }
        },
        focusItem(ctx2, event) {
          ctx2.highlightedId = event.id;
        },
        focusTrigger(ctx2) {
          if (ctx2.isSubmenu || ctx2.anchorPoint || !ctx2.focusTriggerOnClose)
            return;
          raf(() => {
            var _a;
            return (_a = dom.getTriggerEl(ctx2)) == null ? void 0 : _a.focus();
          });
        },
        focusMatchedItem(ctx2, evt) {
          const node = dom.getElemByKey(ctx2, evt.key);
          if (node)
            ctx2.highlightedId = node.id;
        },
        setParentMenu(ctx2, evt) {
          ctx2.parent = ref(evt.value);
        },
        setChildMenu(ctx2, evt) {
          ctx2.children[evt.id] = ref(evt.value);
        },
        closeRootMenu(ctx2) {
          closeRootMenu(ctx2);
        },
        openSubmenu(ctx2) {
          const item = dom.getFocusedItem(ctx2);
          const id = item == null ? void 0 : item.getAttribute("data-uid");
          const child = id ? ctx2.children[id] : null;
          child == null ? void 0 : child.send("OPEN_AUTOFOCUS");
        },
        focusParentMenu(ctx2) {
          var _a;
          (_a = ctx2.parent) == null ? void 0 : _a.send("FOCUS_MENU");
        },
        setHoveredItem(ctx2, evt) {
          ctx2.hoverId = evt.id;
        },
        restoreFocus(ctx2) {
          if (!ctx2.hoverId)
            return;
          ctx2.highlightedId = ctx2.hoverId;
          ctx2.hoverId = null;
        },
        restoreParentFocus(ctx2) {
          var _a;
          (_a = ctx2.parent) == null ? void 0 : _a.send("RESTORE_FOCUS");
        },
        setPointerdownNode(ctx2, evt) {
          ctx2.pointerdownNode = ref(evt.target);
        },
        clearPointerdownNode(ctx2) {
          ctx2.pointerdownNode = null;
        },
        invokeOnOpen(ctx2) {
          var _a;
          (_a = ctx2.onOpen) == null ? void 0 : _a.call(ctx2);
        },
        invokeOnClose(ctx2) {
          var _a;
          (_a = ctx2.onClose) == null ? void 0 : _a.call(ctx2);
        }
      }
    }
  );
}
function closeRootMenu(ctx) {
  let parent = ctx.parent;
  while (parent && parent.state.context.isSubmenu) {
    parent = parent.state.context.parent;
  }
  parent == null ? void 0 : parent.send("CLOSE");
}

export {
  machine
};
