'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var defineProperty = require('../../../../dist/defineProperty-6ca2d9a5.cjs.prod.js');
var classPrivateFieldGet = require('../../../../dist/classPrivateFieldGet-ee0bcee0.cjs.prod.js');
var evm_wallets_abstract_dist_thirdwebDevWalletsEvmWalletsAbstract = require('../../../../dist/abstract-221871d8.cjs.prod.js');
var storage = require('../../../../dist/storage-97213a4f.cjs.prod.js');
require('ethers');
require('eventemitter3');
require('localforage');

var _wallletId = /*#__PURE__*/new WeakMap();
class AbstractBrowserWallet extends evm_wallets_abstract_dist_thirdwebDevWalletsEvmWalletsAbstract.AbstractWallet {
  constructor(walletId, options) {
    super();
    classPrivateFieldGet._classPrivateFieldInitSpec(this, _wallletId, {
      writable: true,
      value: void 0
    });
    defineProperty._defineProperty(this, "coordinatorStorage", void 0);
    defineProperty._defineProperty(this, "walletStorage", void 0);
    defineProperty._defineProperty(this, "chains", void 0);
    defineProperty._defineProperty(this, "options", void 0);
    classPrivateFieldGet._classPrivateFieldSet(this, _wallletId, walletId);
    this.options = options;
    this.chains = options.chains || evm_wallets_abstract_dist_thirdwebDevWalletsEvmWalletsAbstract.thirdwebChains;
    this.coordinatorStorage = storage.getCoordinatorStorage();
    this.walletStorage = storage.getWalletStorage(walletId);
    if (options.shouldAutoConnect !== false) {
      this.autoConnect();
    }
  }
  async autoConnect() {
    const lastConnectedWallet = await this.coordinatorStorage.getItem("lastConnectedWallet");
    if (lastConnectedWallet === classPrivateFieldGet._classPrivateFieldGet(this, _wallletId)) {
      const lastConnectionParams = await this.walletStorage.getItem("lasConnectedParams");
      let parsedParams;
      try {
        parsedParams = JSON.parse(lastConnectionParams);
      } catch {
        parsedParams = undefined;
      }
      const connector = await this.getConnector();
      if (await connector.isConnected()) {
        return await this.connect(parsedParams);
      }
    }
  }
  async connect(connectOptions) {
    const connector = await this.getConnector();
    // setup listeners to re-expose events
    connector.on("connect", data => {
      this.coordinatorStorage.setItem("lastConnectedWallet", classPrivateFieldGet._classPrivateFieldGet(this, _wallletId));
      this.emit("connect", {
        address: data.account,
        chainId: data.chain?.id
      });
      if (data.chain?.id) {
        this.walletStorage.setItem("lastConnectedChain", data.chain?.id);
      }
    });
    connector.on("change", data => {
      this.emit("change", {
        address: data.account,
        chainId: data.chain?.id
      });
      if (data.chain?.id) {
        this.walletStorage.setItem("lastConnectedChain", data.chain?.id);
      }
    });
    connector.on("message", data => this.emit("message", data));
    connector.on("disconnect", () => this.emit("disconnect"));
    connector.on("error", error => this.emit("error", error));
    // end event listener setups
    let connectedAddress = await connector.connect(connectOptions);
    // do not break on coordinator error
    try {
      await this.coordinatorStorage.setItem("lastConnectedWallet", classPrivateFieldGet._classPrivateFieldGet(this, _wallletId));
    } catch {}
    return connectedAddress;
  }
  async getSigner() {
    const connector = await this.getConnector();
    if (!connector) {
      throw new Error("Wallet not connected");
    }
    return await connector.getSigner();
  }
  async disconnect() {
    const connector = await this.getConnector();
    if (connector) {
      connector.removeAllListeners();
      await connector.disconnect();
      // get the last connected wallet and check if it's this wallet, if so, remove it
      const lastConnectedWallet = await this.coordinatorStorage.getItem("lastConnectedWallet");
      if (lastConnectedWallet === classPrivateFieldGet._classPrivateFieldGet(this, _wallletId)) {
        await this.coordinatorStorage.removeItem("lastConnectedWallet");
      }
    }
  }
  async switchChain(chainId) {
    const connector = await this.getConnector();
    if (!connector) {
      throw new Error("Wallet not connected");
    }
    if (!connector.switchChain) {
      throw new Error("Wallet does not support switching chains");
    }
    return await connector.switchChain(chainId);
  }
}

exports.AbstractBrowserWallet = AbstractBrowserWallet;
