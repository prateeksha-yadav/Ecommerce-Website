import { _ as _defineProperty } from '../../../../dist/defineProperty-e24c82ea.esm.js';
import { _ as _classPrivateFieldInitSpec, b as _classPrivateFieldSet, a as _classPrivateFieldGet } from '../../../../dist/classPrivateFieldGet-5cbab388.esm.js';
import { A as AbstractWallet, t as thirdwebChains } from '../../../../dist/abstract-c169745b.esm.js';
import { g as getCoordinatorStorage, a as getWalletStorage } from '../../../../dist/storage-d861365e.esm.js';
import 'ethers';
import 'eventemitter3';
import 'localforage';

var _wallletId = /*#__PURE__*/new WeakMap();
class AbstractBrowserWallet extends AbstractWallet {
  constructor(walletId, options) {
    super();
    _classPrivateFieldInitSpec(this, _wallletId, {
      writable: true,
      value: void 0
    });
    _defineProperty(this, "coordinatorStorage", void 0);
    _defineProperty(this, "walletStorage", void 0);
    _defineProperty(this, "chains", void 0);
    _defineProperty(this, "options", void 0);
    _classPrivateFieldSet(this, _wallletId, walletId);
    this.options = options;
    this.chains = options.chains || thirdwebChains;
    this.coordinatorStorage = getCoordinatorStorage();
    this.walletStorage = getWalletStorage(walletId);
    if (options.shouldAutoConnect !== false) {
      this.autoConnect();
    }
  }
  async autoConnect() {
    const lastConnectedWallet = await this.coordinatorStorage.getItem("lastConnectedWallet");
    if (lastConnectedWallet === _classPrivateFieldGet(this, _wallletId)) {
      const lastConnectionParams = await this.walletStorage.getItem("lasConnectedParams");
      let parsedParams;
      try {
        parsedParams = JSON.parse(lastConnectionParams);
      } catch {
        parsedParams = undefined;
      }
      const connector = await this.getConnector();
      if (await connector.isConnected()) {
        return await this.connect(parsedParams);
      }
    }
  }
  async connect(connectOptions) {
    const connector = await this.getConnector();
    // setup listeners to re-expose events
    connector.on("connect", data => {
      this.coordinatorStorage.setItem("lastConnectedWallet", _classPrivateFieldGet(this, _wallletId));
      this.emit("connect", {
        address: data.account,
        chainId: data.chain?.id
      });
      if (data.chain?.id) {
        this.walletStorage.setItem("lastConnectedChain", data.chain?.id);
      }
    });
    connector.on("change", data => {
      this.emit("change", {
        address: data.account,
        chainId: data.chain?.id
      });
      if (data.chain?.id) {
        this.walletStorage.setItem("lastConnectedChain", data.chain?.id);
      }
    });
    connector.on("message", data => this.emit("message", data));
    connector.on("disconnect", () => this.emit("disconnect"));
    connector.on("error", error => this.emit("error", error));
    // end event listener setups
    let connectedAddress = await connector.connect(connectOptions);
    // do not break on coordinator error
    try {
      await this.coordinatorStorage.setItem("lastConnectedWallet", _classPrivateFieldGet(this, _wallletId));
    } catch {}
    return connectedAddress;
  }
  async getSigner() {
    const connector = await this.getConnector();
    if (!connector) {
      throw new Error("Wallet not connected");
    }
    return await connector.getSigner();
  }
  async disconnect() {
    const connector = await this.getConnector();
    if (connector) {
      connector.removeAllListeners();
      await connector.disconnect();
      // get the last connected wallet and check if it's this wallet, if so, remove it
      const lastConnectedWallet = await this.coordinatorStorage.getItem("lastConnectedWallet");
      if (lastConnectedWallet === _classPrivateFieldGet(this, _wallletId)) {
        await this.coordinatorStorage.removeItem("lastConnectedWallet");
      }
    }
  }
  async switchChain(chainId) {
    const connector = await this.getConnector();
    if (!connector) {
      throw new Error("Wallet not connected");
    }
    if (!connector.switchChain) {
      throw new Error("Wallet does not support switching chains");
    }
    return await connector.switchChain(chainId);
  }
}

export { AbstractBrowserWallet };
