import { _ as _defineProperty } from '../../../../dist/defineProperty-e24c82ea.esm.js';
import { _ as _classPrivateFieldInitSpec, a as _classPrivateFieldGet, b as _classPrivateFieldSet } from '../../../../dist/classPrivateFieldGet-5cbab388.esm.js';
import { A as AbstractWallet } from '../../../../dist/abstract-c169745b.esm.js';
import { AbstractBrowserWallet } from '../../base/dist/thirdweb-dev-wallets-evm-wallets-base.esm.js';
import { ethers } from 'ethers';
import 'eventemitter3';
import '../../../../dist/storage-d861365e.esm.js';
import 'localforage';

var _connector = /*#__PURE__*/new WeakMap();
class DeviceBrowserWallet extends AbstractBrowserWallet {
  get walletName() {
    return "Device Wallet";
  }
  constructor(options) {
    super(DeviceBrowserWallet.id, {
      ...options,
      shouldAutoConnect: false // TODO figure the autoconnect flow
    });
    _classPrivateFieldInitSpec(this, _connector, {
      writable: true,
      value: void 0
    });
  }
  async getConnector() {
    if (!_classPrivateFieldGet(this, _connector)) {
      // import the connector dynamically
      const {
        DeviceWalletConnector
      } = await import('../../../connectors/device-wallet/dist/thirdweb-dev-wallets-evm-connectors-device-wallet.esm.js');
      let wallet;
      switch (this.options.storage) {
        case "localStore":
          wallet = await DeviceWalletImpl.fromBrowserStorage();
          break;
        case "credentialStore":
          wallet = await DeviceWalletImpl.fromCredentialStore();
          break;
        default:
          // default to local storage
          wallet = await DeviceWalletImpl.fromBrowserStorage();
      }
      _classPrivateFieldSet(this, _connector, new DeviceWalletConnector({
        chain: this.options.chain,
        wallet
      }));
    }
    return _classPrivateFieldGet(this, _connector);
  }
}
_defineProperty(DeviceBrowserWallet, "id", "deviceWallet");
var _wallet = /*#__PURE__*/new WeakMap();
class DeviceWalletImpl extends AbstractWallet {
  static async fromBrowserStorage() {
    return new DeviceWalletImpl({
      storage: new BrowserStorage(window.localStorage)
    });
  }
  static async fromCredentialStore() {
    return new DeviceWalletImpl({
      storage: new CredentialsStorage(navigator.credentials)
    });
  }
  constructor(options) {
    super();
    _defineProperty(this, "options", void 0);
    _classPrivateFieldInitSpec(this, _wallet, {
      writable: true,
      value: void 0
    });
    this.options = options;
  }
  async getSigner(provider) {
    if (!_classPrivateFieldGet(this, _wallet)) {
      throw new Error("Wallet not initialized");
    }
    let wallet = _classPrivateFieldGet(this, _wallet);
    if (provider) {
      wallet = wallet.connect(provider);
    }
    return wallet;
  }
  async getSavedWalletAddress() {
    const data = await this.options.storage.getWalletData();
    if (!data) {
      return null;
    }
    return data.address;
  }
  async generateNewWallet() {
    const wallet = ethers.Wallet.createRandom();
    _classPrivateFieldSet(this, _wallet, wallet);
    return wallet.address;
  }
  async loadSavedWallet(password) {
    const data = await this.options.storage.getWalletData();
    if (!data) {
      throw new Error("No saved wallet");
    }
    const wallet = await ethers.Wallet.fromEncryptedJson(data.encryptedData, password);
    _classPrivateFieldSet(this, _wallet, wallet);
    return wallet.address;
  }
  async save(password) {
    const wallet = await this.getSigner();
    // reduce the scrypt cost to make it faster
    const options = {
      scrypt: {
        N: 1 << 32
      }
    };
    const encryptedData = await wallet.encrypt(password, options);
    await this.options.storage.storeWalletData({
      address: wallet.address,
      encryptedData
    });
  }
  async export(password) {
    const wallet = await this.getSigner();
    return wallet.encrypt(password);
  }
}
class BrowserStorage {
  constructor(storage) {
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "STORAGE_KEY_DATA", "tw_wallet_data");
    _defineProperty(this, "STORAGE_KEY_ADDR", "tw_wallet_address");
    this.storage = storage;
  }
  async getWalletData() {
    const address = this.storage.getItem(this.STORAGE_KEY_ADDR);
    const encryptedData = this.storage.getItem(this.STORAGE_KEY_DATA);
    if (!address || !encryptedData) {
      return null;
    }
    return {
      address,
      encryptedData
    };
  }
  async storeWalletData(data) {
    this.storage.setItem(this.STORAGE_KEY_ADDR, data.address);
    this.storage.setItem(this.STORAGE_KEY_DATA, data.encryptedData);
  }
}
class CredentialsStorage {
  constructor(container) {
    _defineProperty(this, "container", void 0);
    this.container = container;
  }
  async getWalletData() {
    const credential = await this.container.get({
      password: true,
      unmediated: true
    });
    console.log(credential);
    if (credential && "password" in credential) {
      return {
        address: credential.id,
        encryptedData: credential.password
      };
    }
    return null;
  }
  async storeWalletData(data) {
    if ("PasswordCredential" in window) {
      let credentialData = {
        id: data.address,
        password: data.encryptedData
      };
      const credential = await this.container.create({
        password: credentialData
      });
      if (!credential) {
        throw new Error("Credential not created");
      }
      await this.container.store(credential);
    } else {
      throw new Error("PasswordCredential not supported");
    }
  }
}

export { DeviceBrowserWallet, DeviceWalletImpl };
