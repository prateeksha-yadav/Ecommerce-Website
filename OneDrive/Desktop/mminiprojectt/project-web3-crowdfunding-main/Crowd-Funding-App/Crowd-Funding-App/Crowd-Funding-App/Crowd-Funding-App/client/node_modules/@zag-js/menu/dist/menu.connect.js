"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/menu.connect.ts
var menu_connect_exports = {};
__export(menu_connect_exports, {
  connect: () => connect
});
module.exports = __toCommonJS(menu_connect_exports);
var import_core = require("@zag-js/core");

// ../../utilities/dom/src/attrs.ts
var dataAttr = (guard) => {
  return guard ? "" : void 0;
};

// ../../utilities/core/src/array.ts
var first = (v) => v[0];
var last = (v) => v[v.length - 1];

// ../../utilities/core/src/guard.ts
var isArray = (v) => Array.isArray(v);
var isObject = (v) => !(v == null || typeof v !== "object" || isArray(v));
var hasProp = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);

// ../../utilities/dom/src/platform.ts
var isDom = () => typeof window !== "undefined";
function getPlatform() {
  var _a;
  const agent = navigator.userAgentData;
  return (_a = agent == null ? void 0 : agent.platform) != null ? _a : navigator.platform;
}
var pt = (v) => isDom() && v.test(getPlatform());
var isTouchDevice = () => isDom() && !!navigator.maxTouchPoints;
var isMac = () => pt(/^Mac/) && !isTouchDevice;

// ../../utilities/dom/src/query.ts
function isDocument(el) {
  return el.nodeType === Node.DOCUMENT_NODE;
}
function isWindow(value) {
  return (value == null ? void 0 : value.toString()) === "[object Window]";
}
function getDocument(el) {
  var _a;
  if (isWindow(el))
    return el.document;
  if (isDocument(el))
    return el;
  return (_a = el == null ? void 0 : el.ownerDocument) != null ? _a : document;
}
function getWindow(el) {
  var _a;
  return (_a = el == null ? void 0 : el.ownerDocument.defaultView) != null ? _a : window;
}
function defineDomHelpers(helpers) {
  const dom2 = {
    getRootNode: (ctx) => {
      var _a, _b;
      return (_b = (_a = ctx.getRootNode) == null ? void 0 : _a.call(ctx)) != null ? _b : document;
    },
    getDoc: (ctx) => getDocument(dom2.getRootNode(ctx)),
    getWin: (ctx) => {
      var _a;
      return (_a = dom2.getDoc(ctx).defaultView) != null ? _a : window;
    },
    getActiveElement: (ctx) => dom2.getDoc(ctx).activeElement,
    getById: (ctx, id) => dom2.getRootNode(ctx).getElementById(id)
  };
  return {
    ...dom2,
    ...helpers
  };
}
function contains(parent, child) {
  if (!parent)
    return false;
  return parent === child || isHTMLElement(parent) && isHTMLElement(child) && parent.contains(child);
}
function isHTMLElement(v) {
  return typeof v === "object" && (v == null ? void 0 : v.nodeType) === Node.ELEMENT_NODE && typeof (v == null ? void 0 : v.nodeName) === "string";
}
function isElementEditable(el) {
  if (el == null || !isHTMLElement(el)) {
    return false;
  }
  try {
    const win = getWindow(el);
    return el instanceof win.HTMLInputElement && el.selectionStart != null || /(textarea|select)/.test(el.localName) || el.isContentEditable;
  } catch {
    return false;
  }
}

// ../../utilities/dom/src/event.ts
function getNativeEvent(e) {
  var _a;
  return (_a = e.nativeEvent) != null ? _a : e;
}
function isSelfEvent(event) {
  return contains(event.currentTarget, event.target);
}
var isTouchEvent = (v) => isObject(v) && hasProp(v, "touches");
var isLeftClick = (v) => v.button === 0;
var isContextMenuEvent = (e) => {
  return e.button === 2 || isCtrlKey(e) && e.button === 0;
};
var isModifiedEvent = (v) => v.ctrlKey || v.altKey || v.metaKey;
var isCtrlKey = (v) => isMac() ? v.metaKey && !v.ctrlKey : v.ctrlKey && !v.metaKey;

// ../../utilities/dom/src/get-event-point.ts
var fallback = {
  pageX: 0,
  pageY: 0,
  clientX: 0,
  clientY: 0
};
function getEventPoint(event, type = "page") {
  var _a, _b;
  const point = isTouchEvent(event) ? (_b = (_a = event.touches[0]) != null ? _a : event.changedTouches[0]) != null ? _b : fallback : event;
  return { x: point[`${type}X`], y: point[`${type}Y`] };
}

// ../../utilities/dom/src/keyboard-event.ts
var rtlKeyMap = {
  ArrowLeft: "ArrowRight",
  ArrowRight: "ArrowLeft"
};
var sameKeyMap = {
  Up: "ArrowUp",
  Down: "ArrowDown",
  Esc: "Escape",
  " ": "Space",
  ",": "Comma",
  Left: "ArrowLeft",
  Right: "ArrowRight"
};
function getEventKey(event, options = {}) {
  var _a;
  const { dir = "ltr", orientation = "horizontal" } = options;
  let { key } = event;
  key = (_a = sameKeyMap[key]) != null ? _a : key;
  const isRtl = dir === "rtl" && orientation === "horizontal";
  if (isRtl && key in rtlKeyMap) {
    key = rtlKeyMap[key];
  }
  return key;
}

// ../../utilities/dom/src/nodelist.ts
function queryAll(root, selector) {
  var _a;
  return Array.from((_a = root == null ? void 0 : root.querySelectorAll(selector)) != null ? _a : []);
}
function itemById(v, id) {
  return v.find((node) => node.id === id);
}
function indexOfId(v, id) {
  const item = itemById(v, id);
  return item ? v.indexOf(item) : -1;
}
function nextById(v, id, loop = true) {
  let idx = indexOfId(v, id);
  idx = loop ? (idx + 1) % v.length : Math.min(idx + 1, v.length - 1);
  return v[idx];
}
function prevById(v, id, loop = true) {
  let idx = indexOfId(v, id);
  if (idx === -1)
    return loop ? v[v.length - 1] : null;
  idx = loop ? (idx - 1 + v.length) % v.length : Math.max(0, idx - 1);
  return v[idx];
}
var getValueText = (item) => {
  var _a, _b;
  return (_b = (_a = item.dataset.valuetext) != null ? _a : item.textContent) != null ? _b : "";
};
var match = (valueText, query) => valueText.toLowerCase().startsWith(query.toLowerCase());
var wrap = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};
function findByText(v, text, currentId) {
  const index = currentId ? indexOfId(v, currentId) : -1;
  let items = currentId ? wrap(v, index) : v;
  const isSingleKey = text.length === 1;
  if (isSingleKey) {
    items = items.filter((item) => item.id !== currentId);
  }
  return items.find((item) => match(getValueText(item), text));
}

// ../../utilities/dom/src/typeahead.ts
function findByTypeaheadImpl(_items, options) {
  const { state, activeId, key, timeout = 350 } = options;
  const search = state.keysSoFar + key;
  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);
  const query = isRepeated ? search[0] : search;
  let items = _items.slice();
  const next = findByText(items, query, activeId);
  function cleanup() {
    clearTimeout(state.timer);
    state.timer = -1;
  }
  function update(value) {
    state.keysSoFar = value;
    cleanup();
    if (value !== "") {
      state.timer = +setTimeout(() => {
        update("");
        cleanup();
      }, timeout);
    }
  }
  update(search);
  return next;
}
var findByTypeahead = /* @__PURE__ */ Object.assign(findByTypeaheadImpl, {
  defaultOptions: {
    keysSoFar: "",
    timer: -1
  },
  isValidEvent: isValidTypeaheadEvent
});
function isValidTypeaheadEvent(event) {
  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}

// src/menu.connect.ts
var import_popper = require("@zag-js/popper");

// src/menu.anatomy.ts
var import_anatomy = require("@zag-js/anatomy");
var anatomy = (0, import_anatomy.createAnatomy)("menu").parts(
  "trigger",
  "triggerItem",
  "positioner",
  "arrow",
  "arrowTip",
  "content",
  "separator",
  "item",
  "optionItem",
  "itemGroupLabel",
  "itemGroup"
);
var parts = anatomy.build();

// src/menu.dom.ts
var dom = defineDomHelpers({
  getTriggerId: (ctx) => {
    var _a, _b;
    return (_b = (_a = ctx.ids) == null ? void 0 : _a.trigger) != null ? _b : `menu:${ctx.id}:trigger`;
  },
  getContextTriggerId: (ctx) => {
    var _a, _b;
    return (_b = (_a = ctx.ids) == null ? void 0 : _a.contextTrigger) != null ? _b : `menu:${ctx.id}:ctx-trigger`;
  },
  getContentId: (ctx) => {
    var _a, _b;
    return (_b = (_a = ctx.ids) == null ? void 0 : _a.content) != null ? _b : `menu:${ctx.id}:content`;
  },
  getArrowId: (ctx) => `menu:${ctx.id}:arrow`,
  getPositionerId: (ctx) => `menu:${ctx.id}:popper`,
  getGroupId: (ctx, id) => {
    var _a, _b, _c;
    return (_c = (_b = (_a = ctx.ids) == null ? void 0 : _a.group) == null ? void 0 : _b.call(_a, id)) != null ? _c : `menu:${ctx.id}:group:${id}`;
  },
  getGroupLabelId: (ctx, id) => {
    var _a, _b, _c;
    return (_c = (_b = (_a = ctx.ids) == null ? void 0 : _a.label) == null ? void 0 : _b.call(_a, id)) != null ? _c : `menu:${ctx.id}:label:${id}`;
  },
  getContentEl: (ctx) => dom.getById(ctx, dom.getContentId(ctx)),
  getPositionerEl: (ctx) => dom.getById(ctx, dom.getPositionerId(ctx)),
  getTriggerEl: (ctx) => dom.getById(ctx, dom.getTriggerId(ctx)),
  getFocusedItem: (ctx) => ctx.highlightedId ? dom.getById(ctx, ctx.highlightedId) : null,
  getArrowEl: (ctx) => dom.getById(ctx, dom.getArrowId(ctx)),
  getElements: (ctx) => {
    const ownerId = CSS.escape(dom.getContentId(ctx));
    const selector = `[role^="menuitem"][data-ownedby=${ownerId}]:not([data-disabled])`;
    return queryAll(dom.getContentEl(ctx), selector);
  },
  getFirstEl: (ctx) => first(dom.getElements(ctx)),
  getLastEl: (ctx) => last(dom.getElements(ctx)),
  getNextEl: (ctx, loop) => nextById(dom.getElements(ctx), ctx.highlightedId, loop != null ? loop : ctx.loop),
  getPrevEl: (ctx, loop) => prevById(dom.getElements(ctx), ctx.highlightedId, loop != null ? loop : ctx.loop),
  getElemByKey: (ctx, key) => findByTypeahead(dom.getElements(ctx), { state: ctx.typeahead, key, activeId: ctx.highlightedId }),
  isTargetDisabled: (v) => {
    return isHTMLElement(v) && v.dataset.disabled === "";
  },
  isTriggerItem: (el) => {
    var _a;
    return !!((_a = el == null ? void 0 : el.getAttribute("role")) == null ? void 0 : _a.startsWith("menuitem")) && !!(el == null ? void 0 : el.hasAttribute("aria-controls"));
  }
});

// src/menu.connect.ts
function connect(state, send, normalize) {
  var _a;
  const isSubmenu = state.context.isSubmenu;
  const values = state.context.value;
  const isTypingAhead = state.context.isTypingAhead;
  const isOpen = state.hasTag("visible");
  const popperStyles = (0, import_popper.getPlacementStyles)({
    measured: !!state.context.anchorPoint || !!state.context.currentPlacement,
    placement: state.context.currentPlacement
  });
  const api = {
    isOpen,
    open() {
      send("OPEN");
    },
    close() {
      send("CLOSE");
    },
    highlightedId: state.context.highlightedId,
    setHighlightedId(id) {
      send({ type: "SET_HIGHLIGHTED_ID", id });
    },
    setParent(parent) {
      send({ type: "SET_PARENT", value: parent, id: parent.state.context.id });
    },
    setChild(child) {
      send({ type: "SET_CHILD", value: child, id: child.state.context.id });
    },
    value: values,
    setValue(name, value) {
      send({ type: "SET_VALUE", name, value });
    },
    isOptionChecked(opts) {
      return opts.type === "radio" ? (values == null ? void 0 : values[opts.name]) === opts.value : values == null ? void 0 : values[opts.name].includes(opts.value);
    },
    contextTriggerProps: normalize.element({
      ...parts.trigger.attrs,
      id: dom.getContextTriggerId(state.context),
      onPointerDown(event) {
        if (event.pointerType === "mouse")
          return;
        const evt = getNativeEvent(event);
        send({ type: "CONTEXT_MENU_START", point: getEventPoint(evt) });
      },
      onPointerCancel(event) {
        if (event.pointerType === "mouse")
          return;
        send("CONTEXT_MENU_CANCEL");
      },
      onPointerMove(event) {
        if (event.pointerType === "mouse")
          return;
        send("CONTEXT_MENU_CANCEL");
      },
      onPointerUp(event) {
        if (event.pointerType === "mouse")
          return;
        send("CONTEXT_MENU_CANCEL");
      },
      onContextMenu(event) {
        const evt = getNativeEvent(event);
        send({ type: "CONTEXT_MENU", point: getEventPoint(evt) });
        event.preventDefault();
      },
      style: {
        WebkitTouchCallout: "none",
        userSelect: "none"
      }
    }),
    getTriggerItemProps(childApi) {
      return (0, import_core.mergeProps)(api.getItemProps({ id: childApi.triggerProps.id }), childApi.triggerProps);
    },
    triggerProps: normalize.button({
      ...isSubmenu ? parts.triggerItem.attrs : parts.trigger.attrs,
      "data-placement": state.context.currentPlacement,
      type: "button",
      dir: state.context.dir,
      id: dom.getTriggerId(state.context),
      "data-uid": state.context.id,
      "aria-haspopup": "menu",
      "aria-controls": dom.getContentId(state.context),
      "aria-expanded": isOpen || void 0,
      "data-expanded": dataAttr(isOpen),
      onPointerMove(event) {
        if (event.pointerType !== "mouse")
          return;
        const disabled = dom.isTargetDisabled(event.currentTarget);
        if (disabled || !isSubmenu)
          return;
        send({
          type: "TRIGGER_POINTERMOVE",
          target: event.currentTarget
        });
      },
      onPointerLeave(event) {
        if (event.pointerType !== "mouse")
          return;
        const evt = getNativeEvent(event);
        const disabled = dom.isTargetDisabled(event.currentTarget);
        if (disabled || !isSubmenu)
          return;
        send({
          type: "TRIGGER_POINTERLEAVE",
          target: event.currentTarget,
          point: getEventPoint(evt)
        });
      },
      onClick(event) {
        if (dom.isTriggerItem(event.currentTarget)) {
          send({ type: "TRIGGER_CLICK", target: event.currentTarget });
        }
      },
      onPointerDown(event) {
        const disabled = dom.isTargetDisabled(event.currentTarget);
        const evt = getNativeEvent(event);
        if (!isLeftClick(evt) || disabled || isContextMenuEvent(event))
          return;
        event.preventDefault();
        if (!dom.isTriggerItem(event.currentTarget)) {
          send({ type: "TRIGGER_CLICK", target: event.currentTarget });
        }
      },
      onBlur() {
        send("TRIGGER_BLUR");
      },
      onFocus() {
        send("TRIGGER_FOCUS");
      },
      onKeyDown(event) {
        const keyMap = {
          ArrowDown() {
            send("ARROW_DOWN");
          },
          ArrowUp() {
            send("ARROW_UP");
          },
          Enter() {
            send({ type: "ARROW_DOWN" });
          },
          Space() {
            send({ type: "ARROW_DOWN" });
          }
        };
        const key = getEventKey(event, state.context);
        const exec = keyMap[key];
        if (exec) {
          event.preventDefault();
          exec(event);
        }
      }
    }),
    positionerProps: normalize.element({
      ...parts.positioner.attrs,
      id: dom.getPositionerId(state.context),
      style: popperStyles.floating
    }),
    arrowProps: normalize.element({
      id: dom.getArrowId(state.context),
      ...parts.arrow.attrs,
      style: popperStyles.arrow
    }),
    arrowTipProps: normalize.element({
      ...parts.arrowTip.attrs,
      style: popperStyles.arrowTip
    }),
    contentProps: normalize.element({
      ...parts.content.attrs,
      id: dom.getContentId(state.context),
      "aria-label": state.context["aria-label"],
      hidden: !isOpen,
      role: "menu",
      tabIndex: 0,
      dir: state.context.dir,
      "aria-activedescendant": (_a = state.context.highlightedId) != null ? _a : void 0,
      "aria-labelledby": dom.getTriggerId(state.context),
      "data-placement": state.context.currentPlacement,
      onPointerEnter(event) {
        if (event.pointerType !== "mouse")
          return;
        send("MENU_POINTERENTER");
      },
      onKeyDown(event) {
        if (!isSelfEvent(event))
          return;
        const item = dom.getFocusedItem(state.context);
        const isLink = !!(item == null ? void 0 : item.matches("a[href]"));
        const keyMap = {
          ArrowDown() {
            send("ARROW_DOWN");
          },
          ArrowUp() {
            send("ARROW_UP");
          },
          ArrowLeft() {
            send("ARROW_LEFT");
          },
          ArrowRight() {
            send("ARROW_RIGHT");
          },
          Enter() {
            if (isLink)
              item == null ? void 0 : item.click();
            send("ENTER");
          },
          Space(event2) {
            var _a2;
            if (isTypingAhead) {
              send({ type: "TYPEAHEAD", key: event2.key });
            } else {
              (_a2 = keyMap.Enter) == null ? void 0 : _a2.call(keyMap, event2);
            }
          },
          Home() {
            send("HOME");
          },
          End() {
            send("END");
          },
          Tab(event2) {
            send({ type: "TAB", shiftKey: event2.shiftKey, loop: false });
          }
        };
        const key = getEventKey(event, { dir: state.context.dir });
        const exec = keyMap[key];
        if (exec) {
          const allow = isLink && key === "Enter";
          exec(event);
          if (!allow) {
            event.preventDefault();
          }
        } else {
          const isSingleKey = event.key.length === 1;
          const isValidTypeahead = isSingleKey && !isModifiedEvent(event) && !isElementEditable(item);
          if (!isValidTypeahead)
            return;
          send({ type: "TYPEAHEAD", key: event.key });
          event.preventDefault();
        }
      }
    }),
    separatorProps: normalize.element({
      ...parts.separator.attrs,
      role: "separator",
      "aria-orientation": "horizontal"
    }),
    getItemProps(options) {
      const { id, disabled, valueText } = options;
      return normalize.element({
        ...parts.item.attrs,
        id,
        role: "menuitem",
        "aria-disabled": disabled,
        "data-disabled": dataAttr(disabled),
        "data-ownedby": dom.getContentId(state.context),
        "data-focus": dataAttr(state.context.highlightedId === id),
        "data-valuetext": valueText,
        onClick(event) {
          if (disabled)
            return;
          send({ type: "ITEM_CLICK", target: event.currentTarget, id });
        },
        onPointerDown(event) {
          if (disabled)
            return;
          send({ type: "ITEM_POINTERDOWN", target: event.currentTarget, id });
        },
        onPointerUp(event) {
          const evt = getNativeEvent(event);
          if (!isLeftClick(evt) || disabled || state.context.pointerdownNode === event.currentTarget)
            return;
          event.currentTarget.click();
        },
        onPointerLeave(event) {
          if (disabled || event.pointerType !== "mouse")
            return;
          send({ type: "ITEM_POINTERLEAVE", target: event.currentTarget });
        },
        onPointerMove(event) {
          if (disabled || event.pointerType !== "mouse")
            return;
          send({ type: "ITEM_POINTERMOVE", id, target: event.currentTarget });
        },
        onDragStart(event) {
          const isLink = event.currentTarget.matches("a[href]");
          if (isLink)
            event.preventDefault();
        },
        onAuxClick(event) {
          if (disabled)
            return;
          event.preventDefault();
          event.currentTarget.click();
        }
      });
    },
    getOptionItemProps(option) {
      var _a2, _b;
      const { name, type, disabled, onCheckedChange } = option;
      (_a2 = option.id) != null ? _a2 : option.id = option.value;
      (_b = option.valueText) != null ? _b : option.valueText = option.value;
      const checked = api.isOptionChecked(option);
      return Object.assign(
        api.getItemProps(option),
        normalize.element({
          "data-type": type,
          "data-name": name,
          ...parts.optionItem.attrs,
          "data-value": option.value,
          role: `menuitem${type}`,
          "aria-checked": !!checked,
          "data-checked": dataAttr(checked),
          onClick(event) {
            if (disabled)
              return;
            send({ type: "ITEM_CLICK", target: event.currentTarget, option });
            onCheckedChange == null ? void 0 : onCheckedChange(!checked);
          }
        })
      );
    },
    getItemGroupLabelProps(options) {
      return normalize.element({
        id: dom.getGroupLabelId(state.context, options.htmlFor),
        ...parts.itemGroupLabel.attrs
      });
    },
    getItemGroupProps(options) {
      return normalize.element({
        id: dom.getGroupId(state.context, options.id),
        ...parts.itemGroup.attrs,
        "aria-labelledby": options.id,
        role: "group"
      });
    }
  };
  return api;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  connect
});
