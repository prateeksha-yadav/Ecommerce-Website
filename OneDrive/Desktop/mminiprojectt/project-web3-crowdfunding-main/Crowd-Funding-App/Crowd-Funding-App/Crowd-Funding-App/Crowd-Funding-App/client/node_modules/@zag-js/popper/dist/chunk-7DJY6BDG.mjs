import {
  autoUpdate,
  callAll
} from "./chunk-MDQJEIPL.mjs";
import {
  shiftArrow,
  transformOrigin
} from "./chunk-X5LLREVI.mjs";

// src/get-placement.ts
import { arrow, computePosition, flip, offset, shift, size } from "@floating-ui/dom";
var defaultOptions = {
  strategy: "absolute",
  placement: "bottom",
  listeners: true,
  gutter: 8,
  flip: true,
  sameWidth: false,
  overflowPadding: 8
};
function getPlacement(reference, floating, opts = {}) {
  if (!floating || !reference)
    return;
  const options = Object.assign({}, defaultOptions, opts);
  const arrowEl = floating.querySelector("[data-part=arrow]");
  const middleware = [];
  const boundary = typeof options.boundary === "function" ? options.boundary() : options.boundary;
  if (options.flip) {
    middleware.push(
      flip({
        boundary,
        padding: options.overflowPadding
      })
    );
  }
  if (options.gutter || options.offset) {
    const arrowOffset = arrowEl ? arrowEl.offsetHeight / 2 : 0;
    const data = options.gutter ? { mainAxis: options.gutter } : options.offset;
    if ((data == null ? void 0 : data.mainAxis) != null)
      data.mainAxis += arrowOffset;
    middleware.push(offset(data));
  }
  middleware.push(
    shift({
      boundary,
      crossAxis: options.overlap,
      padding: options.overflowPadding
    })
  );
  if (arrowEl) {
    middleware.push(
      arrow({ element: arrowEl, padding: 8 }),
      shiftArrow({ element: arrowEl })
    );
  }
  middleware.push(transformOrigin);
  middleware.push(
    size({
      padding: options.overflowPadding,
      apply({ rects, availableHeight, availableWidth }) {
        const referenceWidth = Math.round(rects.reference.width);
        floating.style.setProperty("--reference-width", `${referenceWidth}px`);
        floating.style.setProperty("--available-width", `${availableWidth}px`);
        floating.style.setProperty("--available-height", `${availableHeight}px`);
        if (options.sameWidth) {
          Object.assign(floating.style, {
            width: `${referenceWidth}px`,
            minWidth: "unset"
          });
        }
        if (options.fitViewport) {
          Object.assign(floating.style, {
            maxWidth: `${availableWidth}px`,
            maxHeight: `${availableHeight}px`
          });
        }
      }
    })
  );
  function compute(config = {}) {
    if (!reference || !floating)
      return;
    const { placement, strategy } = options;
    computePosition(reference, floating, {
      placement,
      middleware,
      strategy,
      ...config
    }).then((data) => {
      var _a;
      const x = Math.round(data.x);
      const y = Math.round(data.y);
      Object.assign(floating.style, {
        position: data.strategy,
        top: "0",
        left: "0",
        transform: `translate3d(${x}px, ${y}px, 0)`
      });
      (_a = options.onComplete) == null ? void 0 : _a.call(options, { ...data, compute });
    });
  }
  compute();
  return callAll(
    options.listeners ? autoUpdate(reference, floating, compute, options.listeners) : void 0,
    options.onCleanup
  );
}
function getBasePlacement(placement) {
  return placement.split("-")[0];
}

export {
  getPlacement,
  getBasePlacement
};
