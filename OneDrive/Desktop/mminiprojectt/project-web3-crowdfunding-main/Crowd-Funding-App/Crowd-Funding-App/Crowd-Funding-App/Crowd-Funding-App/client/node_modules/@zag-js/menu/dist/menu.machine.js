"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/menu.machine.ts
var menu_machine_exports = {};
__export(menu_machine_exports, {
  machine: () => machine
});
module.exports = __toCommonJS(menu_machine_exports);
var import_core = require("@zag-js/core");
var import_dismissable = require("@zag-js/dismissable");

// ../../utilities/core/src/array.ts
var first = (v) => v[0];
var last = (v) => v[v.length - 1];
var add = (v, ...items) => v.concat(items);
var remove = (v, item) => removeAt(v, v.indexOf(item));
var removeAt = (v, i) => {
  if (i > -1)
    v.splice(i, 1);
  return v;
};

// ../../utilities/core/src/functions.ts
var runIfFn = (v, ...a) => {
  const res = typeof v === "function" ? v(...a) : v;
  return res != null ? res : void 0;
};

// ../../utilities/core/src/guard.ts
var isArray = (v) => Array.isArray(v);
var isObject = (v) => !(v == null || typeof v !== "object" || isArray(v));
var hasProp = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);

// ../../utilities/core/src/object.ts
function compact(obj) {
  if (obj === void 0)
    return obj;
  return Object.fromEntries(
    Object.entries(obj).filter(([, value]) => value !== void 0).map(([key, value]) => [key, isObject(value) ? compact(value) : value])
  );
}

// ../../utilities/dom/src/platform.ts
var isDom = () => typeof window !== "undefined";

// ../../utilities/dom/src/query.ts
function isDocument(el) {
  return el.nodeType === Node.DOCUMENT_NODE;
}
function isWindow(value) {
  return (value == null ? void 0 : value.toString()) === "[object Window]";
}
function getDocument(el) {
  var _a;
  if (isWindow(el))
    return el.document;
  if (isDocument(el))
    return el;
  return (_a = el == null ? void 0 : el.ownerDocument) != null ? _a : document;
}
function getWindow(el) {
  var _a;
  return (_a = el == null ? void 0 : el.ownerDocument.defaultView) != null ? _a : window;
}
function defineDomHelpers(helpers) {
  const dom2 = {
    getRootNode: (ctx) => {
      var _a, _b;
      return (_b = (_a = ctx.getRootNode) == null ? void 0 : _a.call(ctx)) != null ? _b : document;
    },
    getDoc: (ctx) => getDocument(dom2.getRootNode(ctx)),
    getWin: (ctx) => {
      var _a;
      return (_a = dom2.getDoc(ctx).defaultView) != null ? _a : window;
    },
    getActiveElement: (ctx) => dom2.getDoc(ctx).activeElement,
    getById: (ctx, id) => dom2.getRootNode(ctx).getElementById(id)
  };
  return {
    ...dom2,
    ...helpers
  };
}
function contains(parent, child) {
  if (!parent)
    return false;
  return parent === child || isHTMLElement(parent) && isHTMLElement(child) && parent.contains(child);
}
function isHTMLElement(v) {
  return typeof v === "object" && (v == null ? void 0 : v.nodeType) === Node.ELEMENT_NODE && typeof (v == null ? void 0 : v.nodeName) === "string";
}
function isElementEditable(el) {
  if (el == null || !isHTMLElement(el)) {
    return false;
  }
  try {
    const win = getWindow(el);
    return el instanceof win.HTMLInputElement && el.selectionStart != null || /(textarea|select)/.test(el.localName) || el.isContentEditable;
  } catch {
    return false;
  }
}

// ../../utilities/dom/src/event.ts
var supportsPointerEvent = () => isDom() && window.onpointerdown === null;
var supportsTouchEvent = () => isDom() && window.ontouchstart === null;
var supportsMouseEvent = () => isDom() && window.onmousedown === null;
var isTouchEvent = (v) => isObject(v) && hasProp(v, "touches");

// ../../utilities/dom/src/get-event-point.ts
var fallback = {
  pageX: 0,
  pageY: 0,
  clientX: 0,
  clientY: 0
};
function getEventPoint(event, type = "page") {
  var _a, _b;
  const point2 = isTouchEvent(event) ? (_b = (_a = event.touches[0]) != null ? _a : event.changedTouches[0]) != null ? _b : fallback : event;
  return { x: point2[`${type}X`], y: point2[`${type}Y`] };
}

// ../../utilities/dom/src/listener.ts
var isRef = (v) => hasProp(v, "current");
var fallback2 = { pageX: 0, pageY: 0, clientX: 0, clientY: 0 };
function extractInfo(event, type = "page") {
  const point2 = isTouchEvent(event) ? event.touches[0] || event.changedTouches[0] || fallback2 : event;
  return {
    point: {
      x: point2[`${type}X`],
      y: point2[`${type}Y`]
    }
  };
}
function addDomEvent(target, eventName, handler, options) {
  const node = isRef(target) ? target.current : runIfFn(target);
  node == null ? void 0 : node.addEventListener(eventName, handler, options);
  return () => {
    node == null ? void 0 : node.removeEventListener(eventName, handler, options);
  };
}
function addPointerEvent(target, event, listener, options) {
  var _a;
  const type = (_a = getEventName(event)) != null ? _a : event;
  return addDomEvent(target, type, wrapHandler(listener, event === "pointerdown"), options);
}
function wrapHandler(fn, filter = false) {
  const listener = (event) => {
    fn(event, extractInfo(event));
  };
  return filter ? filterPrimaryPointer(listener) : listener;
}
function filterPrimaryPointer(fn) {
  return (event) => {
    var _a;
    const win = (_a = event.view) != null ? _a : window;
    const isMouseEvent = event instanceof win.MouseEvent;
    const isPrimary = !isMouseEvent || isMouseEvent && event.button === 0;
    if (isPrimary)
      fn(event);
  };
}
var mouseEventNames = {
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointercancel: "mousecancel",
  pointerover: "mouseover",
  pointerout: "mouseout",
  pointerenter: "mouseenter",
  pointerleave: "mouseleave"
};
var touchEventNames = {
  pointerdown: "touchstart",
  pointermove: "touchmove",
  pointerup: "touchend",
  pointercancel: "touchcancel"
};
function getEventName(evt) {
  if (supportsPointerEvent())
    return evt;
  if (supportsTouchEvent())
    return touchEventNames[evt];
  if (supportsMouseEvent())
    return mouseEventNames[evt];
  return evt;
}

// ../../utilities/dom/src/next-tick.ts
function raf(fn) {
  const id = globalThis.requestAnimationFrame(fn);
  return function cleanup() {
    globalThis.cancelAnimationFrame(id);
  };
}

// ../../utilities/dom/src/nodelist.ts
function queryAll(root, selector) {
  var _a;
  return Array.from((_a = root == null ? void 0 : root.querySelectorAll(selector)) != null ? _a : []);
}
function itemById(v, id) {
  return v.find((node) => node.id === id);
}
function indexOfId(v, id) {
  const item = itemById(v, id);
  return item ? v.indexOf(item) : -1;
}
function nextById(v, id, loop = true) {
  let idx = indexOfId(v, id);
  idx = loop ? (idx + 1) % v.length : Math.min(idx + 1, v.length - 1);
  return v[idx];
}
function prevById(v, id, loop = true) {
  let idx = indexOfId(v, id);
  if (idx === -1)
    return loop ? v[v.length - 1] : null;
  idx = loop ? (idx - 1 + v.length) % v.length : Math.max(0, idx - 1);
  return v[idx];
}
var getValueText = (item) => {
  var _a, _b;
  return (_b = (_a = item.dataset.valuetext) != null ? _a : item.textContent) != null ? _b : "";
};
var match = (valueText, query) => valueText.toLowerCase().startsWith(query.toLowerCase());
var wrap = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};
function findByText(v, text, currentId) {
  const index = currentId ? indexOfId(v, currentId) : -1;
  let items = currentId ? wrap(v, index) : v;
  const isSingleKey = text.length === 1;
  if (isSingleKey) {
    items = items.filter((item) => item.id !== currentId);
  }
  return items.find((item) => match(getValueText(item), text));
}

// ../../utilities/dom/src/typeahead.ts
function findByTypeaheadImpl(_items, options) {
  const { state, activeId, key, timeout = 350 } = options;
  const search = state.keysSoFar + key;
  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);
  const query = isRepeated ? search[0] : search;
  let items = _items.slice();
  const next = findByText(items, query, activeId);
  function cleanup() {
    clearTimeout(state.timer);
    state.timer = -1;
  }
  function update(value) {
    state.keysSoFar = value;
    cleanup();
    if (value !== "") {
      state.timer = +setTimeout(() => {
        update("");
        cleanup();
      }, timeout);
    }
  }
  update(search);
  return next;
}
var findByTypeahead = /* @__PURE__ */ Object.assign(findByTypeaheadImpl, {
  defaultOptions: {
    keysSoFar: "",
    timer: -1
  },
  isValidEvent: isValidTypeaheadEvent
});
function isValidTypeaheadEvent(event) {
  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}

// src/menu.machine.ts
var import_popper = require("@zag-js/popper");

// ../../utilities/rect/src/rect.ts
var point = (x, y) => ({ x, y });
function createRect(r) {
  const { x, y, width, height } = r;
  const midX = x + width / 2;
  const midY = y + height / 2;
  return {
    x,
    y,
    width,
    height,
    minX: x,
    minY: y,
    maxX: x + width,
    maxY: y + height,
    midX,
    midY,
    center: point(midX, midY)
  };
}
function getRectCorners(v) {
  const top = point(v.minX, v.minY);
  const right = point(v.maxX, v.minY);
  const bottom = point(v.maxX, v.maxY);
  const left = point(v.minX, v.maxY);
  return { top, right, bottom, left };
}

// ../../utilities/rect/src/get-polygon.ts
function getElementPolygon(rectValue, placement) {
  const rect = createRect(rectValue);
  const { top, right, left, bottom } = getRectCorners(rect);
  const [base] = placement.split("-");
  return {
    top: [left, top, right, bottom],
    right: [top, right, bottom, left],
    bottom: [top, left, bottom, right],
    left: [right, top, left, bottom]
  }[base];
}

// ../../utilities/rect/src/polygon.ts
function isPointInPolygon(polygon, point2) {
  const { x, y } = point2;
  let c = false;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const xi = polygon[i].x;
    const yi = polygon[i].y;
    const xj = polygon[j].x;
    const yj = polygon[j].y;
    if (yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi) {
      c = !c;
    }
  }
  return c;
}

// src/menu.dom.ts
var dom = defineDomHelpers({
  getTriggerId: (ctx) => {
    var _a, _b;
    return (_b = (_a = ctx.ids) == null ? void 0 : _a.trigger) != null ? _b : `menu:${ctx.id}:trigger`;
  },
  getContextTriggerId: (ctx) => {
    var _a, _b;
    return (_b = (_a = ctx.ids) == null ? void 0 : _a.contextTrigger) != null ? _b : `menu:${ctx.id}:ctx-trigger`;
  },
  getContentId: (ctx) => {
    var _a, _b;
    return (_b = (_a = ctx.ids) == null ? void 0 : _a.content) != null ? _b : `menu:${ctx.id}:content`;
  },
  getArrowId: (ctx) => `menu:${ctx.id}:arrow`,
  getPositionerId: (ctx) => `menu:${ctx.id}:popper`,
  getGroupId: (ctx, id) => {
    var _a, _b, _c;
    return (_c = (_b = (_a = ctx.ids) == null ? void 0 : _a.group) == null ? void 0 : _b.call(_a, id)) != null ? _c : `menu:${ctx.id}:group:${id}`;
  },
  getGroupLabelId: (ctx, id) => {
    var _a, _b, _c;
    return (_c = (_b = (_a = ctx.ids) == null ? void 0 : _a.label) == null ? void 0 : _b.call(_a, id)) != null ? _c : `menu:${ctx.id}:label:${id}`;
  },
  getContentEl: (ctx) => dom.getById(ctx, dom.getContentId(ctx)),
  getPositionerEl: (ctx) => dom.getById(ctx, dom.getPositionerId(ctx)),
  getTriggerEl: (ctx) => dom.getById(ctx, dom.getTriggerId(ctx)),
  getFocusedItem: (ctx) => ctx.highlightedId ? dom.getById(ctx, ctx.highlightedId) : null,
  getArrowEl: (ctx) => dom.getById(ctx, dom.getArrowId(ctx)),
  getElements: (ctx) => {
    const ownerId = CSS.escape(dom.getContentId(ctx));
    const selector = `[role^="menuitem"][data-ownedby=${ownerId}]:not([data-disabled])`;
    return queryAll(dom.getContentEl(ctx), selector);
  },
  getFirstEl: (ctx) => first(dom.getElements(ctx)),
  getLastEl: (ctx) => last(dom.getElements(ctx)),
  getNextEl: (ctx, loop) => nextById(dom.getElements(ctx), ctx.highlightedId, loop != null ? loop : ctx.loop),
  getPrevEl: (ctx, loop) => prevById(dom.getElements(ctx), ctx.highlightedId, loop != null ? loop : ctx.loop),
  getElemByKey: (ctx, key) => findByTypeahead(dom.getElements(ctx), { state: ctx.typeahead, key, activeId: ctx.highlightedId }),
  isTargetDisabled: (v) => {
    return isHTMLElement(v) && v.dataset.disabled === "";
  },
  isTriggerItem: (el) => {
    var _a;
    return !!((_a = el == null ? void 0 : el.getAttribute("role")) == null ? void 0 : _a.startsWith("menuitem")) && !!(el == null ? void 0 : el.hasAttribute("aria-controls"));
  }
});

// src/menu.machine.ts
var { not, and } = import_core.guards;
function machine(userContext) {
  const ctx = compact(userContext);
  return (0, import_core.createMachine)(
    {
      id: "menu",
      initial: "unknown",
      context: {
        highlightedId: null,
        hoverId: null,
        parent: null,
        children: {},
        intentPolygon: null,
        loop: false,
        suspendPointer: false,
        anchorPoint: null,
        closeOnSelect: true,
        isPlacementComplete: false,
        focusTriggerOnClose: true,
        ...ctx,
        pointerdownNode: null,
        typeahead: findByTypeahead.defaultOptions,
        positioning: {
          placement: "bottom-start",
          gutter: 8,
          ...ctx.positioning
        }
      },
      computed: {
        isSubmenu: (ctx2) => ctx2.parent !== null,
        isRtl: (ctx2) => ctx2.dir === "rtl",
        isTypingAhead: (ctx2) => ctx2.typeahead.keysSoFar !== ""
      },
      watch: {
        isSubmenu: "setSubmenuPlacement",
        anchorPoint: "applyAnchorPoint"
      },
      on: {
        SET_PARENT: {
          actions: "setParentMenu"
        },
        SET_CHILD: {
          actions: "setChildMenu"
        },
        OPEN: {
          target: "open",
          actions: "invokeOnOpen"
        },
        OPEN_AUTOFOCUS: {
          internal: true,
          target: "open",
          actions: ["focusFirstItem", "invokeOnOpen"]
        },
        CLOSE: {
          target: "closed",
          actions: "invokeOnClose"
        },
        RESTORE_FOCUS: {
          actions: "restoreFocus"
        },
        SET_VALUE: {
          actions: ["setOptionValue", "invokeOnValueChange"]
        },
        SET_HIGHLIGHTED_ID: {
          actions: "setFocusedItem"
        }
      },
      states: {
        unknown: {
          on: {
            SETUP: "idle"
          }
        },
        idle: {
          on: {
            CONTEXT_MENU_START: {
              target: "opening:contextmenu",
              actions: "setAnchorPoint"
            },
            CONTEXT_MENU: {
              target: "open",
              actions: ["setAnchorPoint", "invokeOnOpen"]
            },
            TRIGGER_CLICK: {
              target: "open",
              actions: "invokeOnOpen"
            },
            TRIGGER_FOCUS: {
              guard: not("isSubmenu"),
              target: "closed"
            },
            TRIGGER_POINTERMOVE: {
              guard: "isSubmenu",
              target: "opening"
            }
          }
        },
        "opening:contextmenu": {
          after: {
            LONG_PRESS_DELAY: {
              target: "open",
              actions: "invokeOnOpen"
            }
          },
          on: {
            CONTEXT_MENU_CANCEL: {
              target: "closed",
              actions: "invokeOnClose"
            }
          }
        },
        opening: {
          after: {
            SUBMENU_OPEN_DELAY: {
              target: "open",
              actions: "invokeOnOpen"
            }
          },
          on: {
            BLUR: {
              target: "closed",
              actions: "invokeOnClose"
            },
            TRIGGER_POINTERLEAVE: {
              target: "closed",
              actions: "invokeOnClose"
            }
          }
        },
        closing: {
          tags: ["visible"],
          activities: ["trackPointerMove", "trackInteractOutside"],
          after: {
            SUBMENU_CLOSE_DELAY: {
              target: "closed",
              actions: ["focusParentMenu", "restoreParentFocus", "invokeOnClose"]
            }
          },
          on: {
            MENU_POINTERENTER: {
              target: "open",
              actions: "clearIntentPolygon"
            },
            POINTER_MOVED_AWAY_FROM_SUBMENU: {
              target: "closed",
              actions: ["focusParentMenu", "restoreParentFocus"]
            }
          }
        },
        closed: {
          entry: ["clearFocusedItem", "focusTrigger", "clearAnchorPoint", "resumePointer"],
          on: {
            CONTEXT_MENU_START: {
              target: "opening:contextmenu",
              actions: "setAnchorPoint"
            },
            CONTEXT_MENU: {
              target: "open",
              actions: ["setAnchorPoint", "invokeOnOpen"]
            },
            TRIGGER_CLICK: {
              target: "open",
              actions: "invokeOnOpen"
            },
            TRIGGER_POINTERMOVE: {
              guard: "isTriggerItem",
              target: "opening"
            },
            TRIGGER_BLUR: "idle",
            ARROW_DOWN: {
              target: "open",
              actions: ["focusFirstItem", "invokeOnOpen"]
            },
            ARROW_UP: {
              target: "open",
              actions: ["focusLastItem", "invokeOnOpen"]
            }
          }
        },
        open: {
          tags: ["visible"],
          activities: ["trackInteractOutside", "computePlacement"],
          entry: ["focusMenu", "resumePointer"],
          exit: ["clearPointerdownNode"],
          on: {
            TRIGGER_CLICK: {
              guard: not("isTriggerItem"),
              target: "closed",
              actions: "invokeOnClose"
            },
            TAB: [
              {
                guard: "isForwardTabNavigation",
                actions: ["focusNextItem"]
              },
              { actions: ["focusPrevItem"] }
            ],
            ARROW_UP: {
              actions: ["focusPrevItem", "focusMenu"]
            },
            ARROW_DOWN: {
              actions: ["focusNextItem", "focusMenu"]
            },
            ARROW_LEFT: {
              guard: "isSubmenu",
              target: "closed",
              actions: ["focusParentMenu", "invokeOnClose"]
            },
            HOME: {
              actions: ["focusFirstItem", "focusMenu"]
            },
            END: {
              actions: ["focusLastItem", "focusMenu"]
            },
            REQUEST_CLOSE: {
              target: "closed",
              actions: "invokeOnClose"
            },
            ARROW_RIGHT: {
              guard: "isTriggerItemFocused",
              actions: "openSubmenu"
            },
            ENTER: [
              {
                guard: "isTriggerItemFocused",
                actions: "openSubmenu"
              },
              {
                guard: "closeOnSelect",
                target: "closed",
                actions: "clickFocusedItem"
              },
              {
                actions: "clickFocusedItem"
              }
            ],
            ITEM_POINTERMOVE: [
              {
                guard: and(not("suspendPointer"), not("isTargetFocused")),
                actions: ["focusItem", "focusMenu"]
              },
              {
                guard: not("isTargetFocused"),
                actions: "setHoveredItem"
              }
            ],
            ITEM_POINTERLEAVE: {
              guard: and(not("suspendPointer"), not("isTriggerItem")),
              actions: "clearFocusedItem"
            },
            ITEM_CLICK: [
              {
                guard: and(not("isTriggerItemFocused"), not("isFocusedItemEditable"), "closeOnSelect"),
                target: "closed",
                actions: [
                  "invokeOnSelect",
                  "changeOptionValue",
                  "invokeOnValueChange",
                  "closeRootMenu",
                  "invokeOnClose"
                ]
              },
              {
                guard: and(not("isTriggerItemFocused"), not("isFocusedItemEditable")),
                actions: ["invokeOnSelect", "changeOptionValue", "invokeOnValueChange"]
              },
              { actions: ["focusItem"] }
            ],
            TRIGGER_POINTERLEAVE: {
              target: "closing",
              actions: "setIntentPolygon"
            },
            ITEM_POINTERDOWN: {
              actions: ["setPointerdownNode", "focusItem"]
            },
            TYPEAHEAD: {
              actions: "focusMatchedItem"
            },
            FOCUS_MENU: {
              actions: "focusMenu"
            }
          }
        }
      }
    },
    {
      delays: {
        LONG_PRESS_DELAY: 700,
        SUBMENU_OPEN_DELAY: 100,
        SUBMENU_CLOSE_DELAY: 100
      },
      guards: {
        closeOnSelect: (ctx2, evt) => {
          var _a, _b;
          return !!((_b = (_a = evt.option) == null ? void 0 : _a.closeOnSelect) != null ? _b : ctx2.closeOnSelect);
        },
        isMenuFocused: (ctx2) => {
          const menu = dom.getContentEl(ctx2);
          const activeElement = dom.getActiveElement(ctx2);
          return contains(menu, activeElement);
        },
        isTargetFocused: (ctx2, evt) => ctx2.highlightedId === evt.target.id,
        isTriggerItem: (_ctx, evt) => dom.isTriggerItem(evt.target),
        isTriggerItemFocused: (ctx2, evt) => {
          var _a;
          const target = (_a = evt.target) != null ? _a : dom.getFocusedItem(ctx2);
          return !!(target == null ? void 0 : target.hasAttribute("aria-controls"));
        },
        isForwardTabNavigation: (_ctx, evt) => !evt.shiftKey,
        isSubmenu: (ctx2) => ctx2.isSubmenu,
        suspendPointer: (ctx2) => ctx2.suspendPointer,
        isFocusedItemEditable: (ctx2) => isElementEditable(dom.getFocusedItem(ctx2)),
        isWithinPolygon: (ctx2, evt) => {
          if (!ctx2.intentPolygon)
            return false;
          return isPointInPolygon(ctx2.intentPolygon, evt.point);
        }
      },
      activities: {
        computePlacement(ctx2) {
          if (ctx2.anchorPoint)
            return;
          ctx2.currentPlacement = ctx2.positioning.placement;
          return (0, import_popper.getPlacement)(dom.getTriggerEl(ctx2), dom.getPositionerEl(ctx2), {
            ...ctx2.positioning,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
              ctx2.isPlacementComplete = true;
            }
          });
        },
        trackInteractOutside(ctx2, _evt, { send }) {
          return (0, import_dismissable.trackDismissableElement)(dom.getContentEl(ctx2), {
            exclude: [dom.getTriggerEl(ctx2)],
            onEscapeKeyDown(event) {
              if (ctx2.isSubmenu)
                event.preventDefault();
              closeRootMenu(ctx2);
            },
            onPointerDownOutside(event) {
              ctx2.focusTriggerOnClose = !event.detail.focusable;
            },
            onDismiss() {
              send({ type: "REQUEST_CLOSE", src: "interact-outside" });
            }
          });
        },
        trackPointerMove(ctx2, _evt, { guards: guards2, send }) {
          const { isWithinPolygon } = guards2;
          ctx2.parent.state.context.suspendPointer = true;
          const doc = dom.getDoc(ctx2);
          return addPointerEvent(doc, "pointermove", (e) => {
            const isMovingToSubmenu = isWithinPolygon(ctx2, { point: getEventPoint(e) });
            if (!isMovingToSubmenu) {
              send("POINTER_MOVED_AWAY_FROM_SUBMENU");
              ctx2.parent.state.context.suspendPointer = false;
            }
          });
        }
      },
      actions: {
        setAnchorPoint(ctx2, evt) {
          ctx2.anchorPoint = evt.point;
        },
        clearAnchorPoint(ctx2) {
          ctx2.anchorPoint = null;
        },
        applyAnchorPoint(ctx2) {
          const point2 = ctx2.anchorPoint;
          if (!point2)
            return;
          const el = dom.getPositionerEl(ctx2);
          if (!el)
            return;
          raf(() => {
            Object.assign(el.style, {
              position: "absolute",
              top: "0",
              left: "0",
              transform: `translate3d(${point2.x}px, ${point2.y}px, 0)`
            });
            ctx2.isPlacementComplete = true;
          });
        },
        setSubmenuPlacement(ctx2) {
          if (!ctx2.isSubmenu)
            return;
          ctx2.positioning.placement = ctx2.isRtl ? "left-start" : "right-start";
          ctx2.positioning.gutter = 0;
        },
        invokeOnValueChange(ctx2, evt) {
          var _a, _b, _c;
          if (!ctx2.value)
            return;
          const name = (_b = evt.name) != null ? _b : (_a = evt.option) == null ? void 0 : _a.name;
          if (!name)
            return;
          const values = ctx2.value[name];
          const valueAsArray = isArray(values) ? Array.from(values) : values;
          (_c = ctx2.onValueChange) == null ? void 0 : _c.call(ctx2, { name, value: valueAsArray });
        },
        setOptionValue(ctx2, evt) {
          if (!ctx2.value)
            return;
          ctx2.value[evt.name] = evt.value;
        },
        changeOptionValue(ctx2, evt) {
          if (!evt.option || !ctx2.value)
            return;
          const { value, type, name } = evt.option;
          const values = ctx2.value[name];
          if (type === "checkbox" && isArray(values)) {
            ctx2.value[name] = values.includes(value) ? remove(values, value) : add(values, value);
          } else {
            ctx2.value[name] = value;
          }
        },
        clickFocusedItem(ctx2) {
          var _a;
          (_a = dom.getFocusedItem(ctx2)) == null ? void 0 : _a.click();
        },
        setIntentPolygon(ctx2, evt) {
          const menu = dom.getContentEl(ctx2);
          const placement = ctx2.currentPlacement;
          if (!menu || !placement)
            return;
          const rect = menu.getBoundingClientRect();
          const polygon = getElementPolygon(rect, placement);
          if (!polygon)
            return;
          const rightSide = (0, import_popper.getBasePlacement)(placement) === "right";
          const bleed = rightSide ? -5 : 5;
          ctx2.intentPolygon = [{ ...evt.point, x: evt.point.x + bleed }, ...polygon];
        },
        clearIntentPolygon(ctx2) {
          ctx2.intentPolygon = null;
        },
        resumePointer(ctx2) {
          if (!ctx2.parent)
            return;
          ctx2.parent.state.context.suspendPointer = false;
        },
        setFocusedItem(ctx2, evt) {
          ctx2.highlightedId = evt.id;
        },
        clearFocusedItem(ctx2) {
          ctx2.highlightedId = null;
        },
        focusMenu(ctx2) {
          raf(() => {
            const activeEl = dom.getActiveElement(ctx2);
            const contentEl = dom.getContentEl(ctx2);
            if (contains(contentEl, activeEl))
              return;
            contentEl == null ? void 0 : contentEl.focus();
          });
        },
        focusFirstItem(ctx2) {
          const first2 = dom.getFirstEl(ctx2);
          if (!first2)
            return;
          ctx2.highlightedId = first2.id;
        },
        focusLastItem(ctx2) {
          const last2 = dom.getLastEl(ctx2);
          if (!last2)
            return;
          ctx2.highlightedId = last2.id;
        },
        focusNextItem(ctx2, evt) {
          var _a;
          const next = dom.getNextEl(ctx2, evt.loop);
          ctx2.highlightedId = (_a = next == null ? void 0 : next.id) != null ? _a : null;
        },
        focusPrevItem(ctx2, evt) {
          var _a;
          const prev = dom.getPrevEl(ctx2, evt.loop);
          ctx2.highlightedId = (_a = prev == null ? void 0 : prev.id) != null ? _a : null;
        },
        invokeOnSelect(ctx2) {
          var _a;
          if (!ctx2.highlightedId)
            return;
          (_a = ctx2.onSelect) == null ? void 0 : _a.call(ctx2, { value: ctx2.highlightedId });
          if (!ctx2.closeOnSelect) {
            ctx2.pointerdownNode = null;
          }
        },
        focusItem(ctx2, event) {
          ctx2.highlightedId = event.id;
        },
        focusTrigger(ctx2) {
          if (ctx2.isSubmenu || ctx2.anchorPoint || !ctx2.focusTriggerOnClose)
            return;
          raf(() => {
            var _a;
            return (_a = dom.getTriggerEl(ctx2)) == null ? void 0 : _a.focus();
          });
        },
        focusMatchedItem(ctx2, evt) {
          const node = dom.getElemByKey(ctx2, evt.key);
          if (node)
            ctx2.highlightedId = node.id;
        },
        setParentMenu(ctx2, evt) {
          ctx2.parent = (0, import_core.ref)(evt.value);
        },
        setChildMenu(ctx2, evt) {
          ctx2.children[evt.id] = (0, import_core.ref)(evt.value);
        },
        closeRootMenu(ctx2) {
          closeRootMenu(ctx2);
        },
        openSubmenu(ctx2) {
          const item = dom.getFocusedItem(ctx2);
          const id = item == null ? void 0 : item.getAttribute("data-uid");
          const child = id ? ctx2.children[id] : null;
          child == null ? void 0 : child.send("OPEN_AUTOFOCUS");
        },
        focusParentMenu(ctx2) {
          var _a;
          (_a = ctx2.parent) == null ? void 0 : _a.send("FOCUS_MENU");
        },
        setHoveredItem(ctx2, evt) {
          ctx2.hoverId = evt.id;
        },
        restoreFocus(ctx2) {
          if (!ctx2.hoverId)
            return;
          ctx2.highlightedId = ctx2.hoverId;
          ctx2.hoverId = null;
        },
        restoreParentFocus(ctx2) {
          var _a;
          (_a = ctx2.parent) == null ? void 0 : _a.send("RESTORE_FOCUS");
        },
        setPointerdownNode(ctx2, evt) {
          ctx2.pointerdownNode = (0, import_core.ref)(evt.target);
        },
        clearPointerdownNode(ctx2) {
          ctx2.pointerdownNode = null;
        },
        invokeOnOpen(ctx2) {
          var _a;
          (_a = ctx2.onOpen) == null ? void 0 : _a.call(ctx2);
        },
        invokeOnClose(ctx2) {
          var _a;
          (_a = ctx2.onClose) == null ? void 0 : _a.call(ctx2);
        }
      }
    }
  );
}
function closeRootMenu(ctx) {
  let parent = ctx.parent;
  while (parent && parent.state.context.isSubmenu) {
    parent = parent.state.context.parent;
  }
  parent == null ? void 0 : parent.send("CLOSE");
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  machine
});
