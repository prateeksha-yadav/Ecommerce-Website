'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var defineProperty = require('../../../../dist/defineProperty-21d22449.cjs.dev.js');
var classPrivateFieldGet = require('../../../../dist/classPrivateFieldGet-6e4ddeb2.cjs.dev.js');
var evm_wallets_abstract_dist_thirdwebDevWalletsEvmWalletsAbstract = require('../../../../dist/abstract-87f231fe.cjs.dev.js');
var evm_wallets_base_dist_thirdwebDevWalletsEvmWalletsBase = require('../../base/dist/thirdweb-dev-wallets-evm-wallets-base.cjs.dev.js');
var ethers = require('ethers');
require('eventemitter3');
require('../../../../dist/storage-b818cf72.cjs.dev.js');
require('localforage');

var _connector = /*#__PURE__*/new WeakMap();
class DeviceBrowserWallet extends evm_wallets_base_dist_thirdwebDevWalletsEvmWalletsBase.AbstractBrowserWallet {
  get walletName() {
    return "Device Wallet";
  }
  constructor(options) {
    super(DeviceBrowserWallet.id, {
      ...options,
      shouldAutoConnect: false // TODO figure the autoconnect flow
    });
    classPrivateFieldGet._classPrivateFieldInitSpec(this, _connector, {
      writable: true,
      value: void 0
    });
  }
  async getConnector() {
    if (!classPrivateFieldGet._classPrivateFieldGet(this, _connector)) {
      // import the connector dynamically
      const {
        DeviceWalletConnector
      } = await Promise.resolve().then(function () { return require('../../../connectors/device-wallet/dist/thirdweb-dev-wallets-evm-connectors-device-wallet.cjs.dev.js'); });
      let wallet;
      switch (this.options.storage) {
        case "localStore":
          wallet = await DeviceWalletImpl.fromBrowserStorage();
          break;
        case "credentialStore":
          wallet = await DeviceWalletImpl.fromCredentialStore();
          break;
        default:
          // default to local storage
          wallet = await DeviceWalletImpl.fromBrowserStorage();
      }
      classPrivateFieldGet._classPrivateFieldSet(this, _connector, new DeviceWalletConnector({
        chain: this.options.chain,
        wallet
      }));
    }
    return classPrivateFieldGet._classPrivateFieldGet(this, _connector);
  }
}
defineProperty._defineProperty(DeviceBrowserWallet, "id", "deviceWallet");
var _wallet = /*#__PURE__*/new WeakMap();
class DeviceWalletImpl extends evm_wallets_abstract_dist_thirdwebDevWalletsEvmWalletsAbstract.AbstractWallet {
  static async fromBrowserStorage() {
    return new DeviceWalletImpl({
      storage: new BrowserStorage(window.localStorage)
    });
  }
  static async fromCredentialStore() {
    return new DeviceWalletImpl({
      storage: new CredentialsStorage(navigator.credentials)
    });
  }
  constructor(options) {
    super();
    defineProperty._defineProperty(this, "options", void 0);
    classPrivateFieldGet._classPrivateFieldInitSpec(this, _wallet, {
      writable: true,
      value: void 0
    });
    this.options = options;
  }
  async getSigner(provider) {
    if (!classPrivateFieldGet._classPrivateFieldGet(this, _wallet)) {
      throw new Error("Wallet not initialized");
    }
    let wallet = classPrivateFieldGet._classPrivateFieldGet(this, _wallet);
    if (provider) {
      wallet = wallet.connect(provider);
    }
    return wallet;
  }
  async getSavedWalletAddress() {
    const data = await this.options.storage.getWalletData();
    if (!data) {
      return null;
    }
    return data.address;
  }
  async generateNewWallet() {
    const wallet = ethers.ethers.Wallet.createRandom();
    classPrivateFieldGet._classPrivateFieldSet(this, _wallet, wallet);
    return wallet.address;
  }
  async loadSavedWallet(password) {
    const data = await this.options.storage.getWalletData();
    if (!data) {
      throw new Error("No saved wallet");
    }
    const wallet = await ethers.ethers.Wallet.fromEncryptedJson(data.encryptedData, password);
    classPrivateFieldGet._classPrivateFieldSet(this, _wallet, wallet);
    return wallet.address;
  }
  async save(password) {
    const wallet = await this.getSigner();
    // reduce the scrypt cost to make it faster
    const options = {
      scrypt: {
        N: 1 << 32
      }
    };
    const encryptedData = await wallet.encrypt(password, options);
    await this.options.storage.storeWalletData({
      address: wallet.address,
      encryptedData
    });
  }
  async export(password) {
    const wallet = await this.getSigner();
    return wallet.encrypt(password);
  }
}
class BrowserStorage {
  constructor(storage) {
    defineProperty._defineProperty(this, "storage", void 0);
    defineProperty._defineProperty(this, "STORAGE_KEY_DATA", "tw_wallet_data");
    defineProperty._defineProperty(this, "STORAGE_KEY_ADDR", "tw_wallet_address");
    this.storage = storage;
  }
  async getWalletData() {
    const address = this.storage.getItem(this.STORAGE_KEY_ADDR);
    const encryptedData = this.storage.getItem(this.STORAGE_KEY_DATA);
    if (!address || !encryptedData) {
      return null;
    }
    return {
      address,
      encryptedData
    };
  }
  async storeWalletData(data) {
    this.storage.setItem(this.STORAGE_KEY_ADDR, data.address);
    this.storage.setItem(this.STORAGE_KEY_DATA, data.encryptedData);
  }
}
class CredentialsStorage {
  constructor(container) {
    defineProperty._defineProperty(this, "container", void 0);
    this.container = container;
  }
  async getWalletData() {
    const credential = await this.container.get({
      password: true,
      unmediated: true
    });
    console.log(credential);
    if (credential && "password" in credential) {
      return {
        address: credential.id,
        encryptedData: credential.password
      };
    }
    return null;
  }
  async storeWalletData(data) {
    if ("PasswordCredential" in window) {
      let credentialData = {
        id: data.address,
        password: data.encryptedData
      };
      const credential = await this.container.create({
        password: credentialData
      });
      if (!credential) {
        throw new Error("Credential not created");
      }
      await this.container.store(credential);
    } else {
      throw new Error("PasswordCredential not supported");
    }
  }
}

exports.DeviceBrowserWallet = DeviceBrowserWallet;
exports.DeviceWalletImpl = DeviceWalletImpl;
